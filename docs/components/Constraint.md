# Constraints

A constraint is used to filter out trip or tour alternatives that do not make sense or are forbidden for some reason. The classic example is to forbid the `car` mode at a location where the vehicle has not been moved to. This is not a dynamic constraint, but can already be inferred when the mode chain is constructed since the origin and destination locations of each trip are known in advance.

The DMC extension contains a number of predefined constraints, but it is also possible to write custom ones. How to do that is explained in [Customizing the model](docs/Customizing.md).

In the following the existing built-in constraints are described. While some of them have additional configuration options that can be defined in a `parameterset`, some don't. In any case, tour or trip constraints can be chosen in the main config group. If a trip-based [model](docs/components/Model.md) is used, the `tripConstraints` are considered, if a tour-based [model](docs/components/Model.md) is used, the `tourConstraints` are used. In each case a unlimited number of constraints, divided by commas, can be defined:

```xml
<module name="DiscreteModeChoice">
	<!-- Defines a number of TripConstraint components that should be activated. Built-in choices: ... -->
	<param name="tripConstraints" value="" />
	
	<!-- Defines a number of TourConstraint components that should be activated. Built-in choices: ... -->
	<param name="tripConstraints" value="" />
</module>
```

## Cumulative

*Description:* The `Cumulative` tour constraint is a special constraint, because it does not perform any filtering itself. Instead, it will look up the `tripConstraints` from the main DMC configuration and used them on a trip-by-trip basis for each tour that needs to be evaluated. Only if the defined trip constraints pass for all trips in a tour, the tour is considered to be valid.

*Level:* Tour

*Configuration:*
No specific configuration availble. The `tripConstraints` attribute from the main DMC config group is used.

## LinkAttribute

*Description:* The link attribute constraint makes it possible to allow or forbid certain modes if a specific link attribute at the origin or destination of the trip shows a specific value. If the requirement is chosen to be `BOTH`, both origin and destination must fulfill the condition. Alternatively, `ORIGIN` (only), `DESTINATION` (only) or `ANY` can be chosen, but it can also be required that `NONE` matches for the constraint to be fulfilled.

*Level*: Trip

*Configuration:*

```xml
<parameterset type="tripConstraint:LinkAttribute" >
	<!-- Link attribute that will be considered for feasibility of the trip. -->
	<param name="attributeName" value="null" />
	<!-- Value that the link attributes should equal. -->
	<param name="attributeValue" value="null" />
	<!-- Modes for which the shapes will be considered. -->
	<param name="constrainedModes" value="" />
	<!-- Defines the criterion on when a trip with the constrained mode will be allowed: ORIGIN, DESTINATION, BOTH, ANY, NONE -->
	<param name="requirement" value="BOTH" />
</parameterset>
```

## ShapeFile

*Description:* The shape file constraint makes it possible to allow or forbid certain modes if the origin and/or destination *coordinate* of the trip is covered by a feature in a given shape file. If the requirement is chosen to be `BOTH`, both origin and destination must fulfill the condition. Alternatively, `ORIGIN` (only), `DESTINATION` (only) or `ANY` can be chosen, but it can also be required that `NONE` matches for the constraint to be fulfilled. The `path` is given relative to the configuration file.

*Level:* Trip

*Configuration:*

```xml
<parameterset type="tripConstraint:ShapeFile" >
	<!-- Modes for which the shapes will be considered. -->
	<param name="constrainedModes" value="" />
	<!-- Path to a shape file, which should have the same projection as the network. -->
	<param name="path" value="null" />
	<!-- Defines the criterion on when a trip with the constrained mode will be allowed: ORIGIN, DESTINATION, BOTH, ANY, NONE -->
	<param name="requirement" value="BOTH" />
</parameterset>
```

## SubtourMode

*Description:* The `SubtourMode` constraint makes sure that only alternatives are considered that could have been generated by `SubtourModeChoice`. It is mainly used to create compatibility with existing MATSim simulations. There are two components to the logic of the constraint: First, historically, `SubtourModeChoice` did not consider multiple non-constrained modes on one sub-tour of a plan. For instance, it was not possible to walk from work to a restaurant and come back by public transport. This has changed since the option `probaForRandomSingleTripMode` has been added to `SubtourModeChoice`. Using this probability one can now demand that single legs which happen to be on a sub-tour of a non-constrained (not chain-based) mode can be replaced by other non-contstrained modes. This only happens if `probaForRandomSingleTripMode > 0`. Second, `SubtourModeChoice` considers the atomic sub-tours of a plan. For instance, a chain of locations like `A -> B -> A -> B -> A` can be covered by a chain of modes like `[car, car, walk, walk]`, but never `[car, pt, pt, car]`. In principle, this is the same constraint: A tour with a constrained mode cannot be interrupted by *any* other mode.

Therefore, the `SubtourMode` costraint only relies on a list of "constrained modes". If one wants to replicate the behaviour of the "old" `SubtourModeChoice`, one needs to add all available modes as "constrained modes". If one wants to replicate the "new" behaviour, only the actual modes, which should also be constrained by a `VehicleConstraint` should be added.

- Replicate `probaForRandomSingleTripMode == 0.0` (old) -> Add all available modes as `constrainedModes`
- Replicate `probaForRandomSingleTripMode > 0.0` (new) -> Add only "chain based" modes as `constrainedModes`

*Level:* Tour

*Configuration:*

```xml
<parameterset type="tourConstraint:SubtourMode" >
	<!-- Modes for which the sub-tour behaviour should be replicated. If all available modes are put here, this equals to SubTourModeChoice with singleLegProbability == 0.0; if only the constrained modes are put here, it equals singleLegProbability > 0.0 -->
	<param name="constrainedModes" value="" />
</parameterset>
```

## TransitWalk

*Description:* This constraint makes sure that no public transit *trips* that only contain one `transit_walk` *leg* are accepted. Usually, there should be another alternative with an actual `walk` *trip* should be available. This is to ensure that no agent chooses the `pt` *mode* when, in fact, there is no sensible connection available.

*Level:* Trip

*Configuration:*
No special configuration.

## VehicleContinuity (Tour)

*Description:* The `VehicleTourConstraint` makes sure that agents have consistent mode chains in their plans. There are three slots that enforce the behaviour:

- `requireContinuity`: These modes can only be used if the respective vehicle has been moved to the new departure location before
- `requireStartsAtHome`: The first trip on a tour with these modes *must* start at the home location of the agent
- `requireEndsAtHome`: At the end of the tour, the vehicles of these modes *must* be back at home

Usually, those three fields are the same, but there are cases when this may not be desired (e.g. if people should start their tours at home with their car, but they can pick up a bike anywhere else).

The *home location* of an agent is not given per se, so it needs to be inferred. Currently, `homeType` can be set either to `USE_FIRST_ACTIVITY`, which declares the location of the first activity in a tour as the "home location". This makes most sense if a plan-based model is used, where the tour in question is, in fact, the whole plan. Also, this setting resembles the behaviour of `SubtourModeChoice`. Alternatively, `USE_ACTIVITY_TYPE` can be chosen, which will search for the first activity of type `homeActivityType` in the tour and declare the location of that activity type as "home location".

In some cases it may be possible that no "home location" can be found for an agent (e.g. if it is through-traffic entering and exiting the simulation scenario at two points). In that case `requireHomeExists` either enforces the constraint, meaning that those people will never be able to use the constrained modes or revokes the "start at home" and "end at home" constraints for that agent.

*Level:* Tour

*Configuration:*

```xml
<parameterset type="tourConstraint:VehicleContinuity" >
	<!-- If USE_ACTIVITY_TYPE is chosen for homeType, this option defines which activity type to look for. -->
	<param name="homeActivityType" value="home" />
	<!-- Defines how to determine where the home of an agent is. -->
	<param name="homeType" value="USE_FIRST_ACTIVITY" />
	<!-- List of vehicular modes that must be consistent, i.e. a trip can only be performed if the vehicle has been moved there before. -->
	<param name="requireContinuity" value="car" />
	<!-- List of vehicular modes that must end at a home activity. -->
	<param name="requireEndAtHome" value="car" />
	<!-- Defines whether an agent without a home activity can use a constrained vehicular mode. If it is set to true agents without a home activity cannot use constrained modes. If it is set to false they can use constrained modes at any stage during their plan. -->
	<param name="requireHomeExists" value="false" />
	<!-- List of vehicular modes that must start at a home activity. -->
	<param name="requireStartAtHome" value="car" />
</parameterset>
```

## VehicleContinuity (Trip)

The trip-based version of the vehicle continuity constraint is configured the same way as the tour-based version. In general, the case is more tricky here, because enforcing a vehicle to arrive at home may mean also forbidding other modes (such as walking) for certain trips, because otherwise there is structurally no possibility to return the vehicle back home. In principle, these cases should be covered by the constraint, but *it has not been tested thoroughly*! Use at own risk, and we'd be happy to see some test cases for it.




